%div{:style => "width:1000px; height:800px; overflow: hidden;"}
  %ul#scrolly

  %ul#scrollyHider{:style => "display:none;"}
    - list_classes = ['notice','success','error','info']
    - 1.upto(40) do |i|
      %li.bubble{:class => list_classes[rand(4)]}
        .content
          %p== I yam thing #{i} and I yam        
        
:javascript
  $(".bubble").mouseover(function(){
    b = bubbles[$(this).attr("data_bubble_id")];
    b.drag = 0.9;
  });
  $(".bubble").mouseout(function(){
    b = bubbles[$(this).attr("data_bubble_id")];
    b.drag = 0.0;
  });
  $(".bubble").click(function(){
    b = bubbles[$(this).attr("data_bubble_id")];
    if(b.mass > 300){
      b.drag = 0.0;
      b.mass = 100;
      b.selector.text(100);
    } else {
      b.drag = 0.98;
      b.mass = 500;
      b.selector.text(500)
    }
  });
  
  var bottom_y = 1200;
  var top_y = -100;
  var fps = 50;
  var animation_interval = 1000. / fps;
  var garbage_collection_interval = 1000;
  var insertion_interval = 500;
  var collision_detection_interval = 50;
  
  var height = 49;
  var width = 204;
  var bubbles = {};
  var next_bubbles_index = 0;
  
  var getBubbleId = function(bubble){
    return bubble.selector.attr("data_bubble_id");
  }
  
  var insertNextBubble = function(){
      // Store the new bubble.
      var selector = $('#scrollyHider li:first-child');
      if(selector.length !== 0){
        
        // Choose start parameters.
        var start_left = Math.floor(Math.random()*800);
        var start_velocity = .2 + Math.random()*.2;
        var start_right = start_left + width;
        var mass = 50 + Math.random()*200;
        var drag = 0;
        
        // selector.css("background-color","rgb("+ Math.floor(mass) + "," + Math.floor(mass) + "," + Math.floor(mass) + ")");
        selector.text(Math.floor(mass));
       
        // Compute the blocker candidates.
        var blocker_candidates_left = [];
        _.each(bubbles, function(b){
          if(start_left <= b.left && start_right > b.left){
            // Add to blocker candidates list.
            blocker_candidates_left.push(b);
          }
        });
        
        // Compute the blocker candidates.
        var blocker_candidates_right = [];
        _.each(bubbles, function(b){
          if(start_right >= b.right && start_left < b.right){
            // Add to blocker candidates list.
            blocker_candidates_right.push(b);
          }
        });
        
        // Compute the left blocker.
        var blocker_y = -100000;
        var blocker_left = false;
        _.each(blocker_candidates_left, function(b){
          var b_y = b.selector.position().top
          if(b_y > blocker_y){
            blocker_y = b_y;
            blocker_left = getBubbleId(b);
          }    
        });
        
        // Compute the right blocker.
        var blocker_y = -100000;
        var blocker_right = false;
        _.each(blocker_candidates_right, function(b){
          var b_y = b.selector.position().top
          if(b_y > blocker_y){
            blocker_y = b_y;
            blocker_right = getBubbleId(b);
          }    
        });
        
        // Save the bubble data.
        bubbles[next_bubbles_index] = {
          selector : selector, 
          blocker_left : blocker_left,
          blocker_right : blocker_right,
          left : start_left,
          right : start_right,
          velocity : start_velocity,
          mass : mass,
          drag : drag,
          dom_el : selector.get(0)
        }
        
        // Save bubble id in dom.
        selector.attr("data_bubble_id", next_bubbles_index);
                      
        // Insert the new bubble and start animating it.
        var time_to_top = (bottom_y - top_y) / start_velocity;
        selector.css('left', start_left).css('top', bottom_y + 'px').prependTo('#scrolly');
        
        next_bubbles_index = next_bubbles_index + 1;
    }
  }
  
  var animateBubbles = function(){
    _.each(bubbles, function(b){
      
      var old_top = parseInt(b.dom_el.style.top.substring(0, b.dom_el.style.top.length - 2));
      b.dom_el.style.top = (old_top - (b.velocity * animation_interval)) + "px";
      
      //var old_top = b.selector.position().top;
      //var new_top = (old_top - (b.velocity * animation_interval));
      // b.selector.css("top", (old_top - (b.velocity * animation_interval)) + "px");
       // b.selector.get(0).style.top = new_top + "px";
      // b.selector.get(0).style.top = "500px";
      if(old_top > 500){
        b.velocity = b.velocity - 0.0010;
      } else {
        b.velocity = b.velocity + 0.002;
      }
      b.velocity = b.velocity * (1 - b.drag);
      if(old_top < 0){
        b.drag = 0.98;
      }
    });
  }
  
  var collectGarbage = function(){
    // Remove any bubbles that are above the top or below the bottom of the page.
    _.each(bubbles, function(b){
      var top = b.selector.position().top;
      if(top <= top_y || top > bottom_y){
        delete bubbles[getBubbleId(b)];
        b.selector.appendTo("#scrollyHider");
      }
    });
  }
  
  var adjustVelocity = function(b1,b2){
    var b2_bottom = parseInt(b2.dom_el.style.top.substring(0, b2.dom_el.style.top.length - 2)) + height;
    var b1_top = parseInt(b1.dom_el.style.top.substring(0, b1.dom_el.style.top.length - 2));
    // var b2_bottom = b2.selector.position().top + height;
    // var b1_top = b1.selector.position().top;
  
    if(b1_top < b2_bottom){
      
      v1_i = b1.velocity;
      v2_i = b2.velocity;
      m1 = b1.mass;
      m2 = b2.mass;
      
      var v1_f = ((m1 - m2)*v1_i + 2*m2*v2_i)/(m1 + m2);
      var v2_f = ((2*(m1*v1_i) - (m1 - m2)*v2_i))/(m1 + m2);
      
      // Elastic force.
      // var d = b2_bottom - b1_top;
      // var k = .01;
      // v1_f = v1_f - k*d/(2*m1);
      // v2_f = v2_f + k*d/(2*m2);
      
      b1.velocity = 0.9*v1_f;
      b2.velocity = 0.9*v2_f;
      b2.dom_el.style.top = b1_top - height + "px";
      //b2.selector.css("top", b1_top - height + "px");
    }
  }
  
  var handleCollisions = function(){
    _.each(bubbles, function(b){
      
      var bubble_id = getBubbleId(b);
      
      // Check if this bubble has collided.
      if(b.blocker_left && bubbles[b.blocker_left] !== undefined){
        adjustVelocity(b,bubbles[b.blocker_left])
      }

      // Check if this bubble has collided.
      if(b.blocker_right && bubbles[b.blocker_right] !== undefined){
        adjustVelocity(b,bubbles[b.blocker_right])
      }


    });
  }
  setInterval(animateBubbles, animation_interval);
  setInterval(insertNextBubble, insertion_interval);
  setInterval(handleCollisions, collision_detection_interval);
  setInterval(collectGarbage, garbage_collection_interval);

